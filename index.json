[{"content":"For MealSpotter, we use Google Analytics Events to help us better understand how well Deals are performing, and bring that insight to our restaurant partners. Ensuring that our analytics data are clean helps us to work with our partners to bring even better deals to our users.\nThis post will go into how to define an Events schema using Typescript, using a simplified example of the method we use at MealSpotter.\nEach event contains the following data:\n Category Action Label (optional) Value (optional)  While the label is optional, having the additional specificity really comes in handy. If you want to assign a monetary value to a particular event, then that field can be used as well.\nThe Code This example uses a similar pattern to Redux with Typescript: You take a broad type and narrow it down to specific events, which are created via helper functions.\nSetup Let\u0026rsquo;s say we want to use events to track how often a user clicks on boxes of various colors. We have a simple component for a Box:\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /* src/box.tsx */ import React from \u0026#39;react\u0026#39;; // type Color = \u0026#39;red\u0026#39; | \u0026#39;green\u0026#39; | \u0026#39;blue\u0026#39;; import Color from \u0026#39;./color\u0026#39;; type Props = { color: Color; onClick(): void; }; export const Box: React.FC\u0026lt;Props\u0026gt; = ({ color, onClick }) =\u0026gt; ( \u0026lt;div style={{ backgroundColor: color, height: \u0026#39;10rem\u0026#39;, width: \u0026#39;30vw\u0026#39;, margin: \u0026#39;8px\u0026#39;, display: \u0026#39;inline-block\u0026#39;, color: \u0026#39;white\u0026#39;, textAlign: \u0026#39;center\u0026#39;, }} onClick={() =\u0026gt; onClick()} \u0026gt; \u0026lt;p style={{ verticalAlign: \u0026#39;middle\u0026#39;, }}\u0026gt; Click me! \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; );    And we render a box for each color in our App:\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  /* src/app.tsx */ import React from \u0026#39;react\u0026#39;; import Box from \u0026#39;./box\u0026#39;; import Color from \u0026#39;./color\u0026#39;; const App: React.FC = () =\u0026gt; { const colors: Color[] = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]; function handleClick(color: Color): void { console.log(`color ${color}clicked`); } const boxes = colors.map((color) =\u0026gt; ( \u0026lt;Box color={color} key={color} onClick={() =\u0026gt; handleClick(color)} /\u0026gt; )); return ( \u0026lt;div\u0026gt; { boxes } \u0026lt;/div\u0026gt; ) }; export default App;    Implementing Events Now that we have the components set up, we can move onto the events. Assuming we have a simple facade to interface with GA:\n0 1 2 3 4 5 6 7 8 9 10  /* src/analytics-facade/i-analytics-facade.ts */ export interface IAnalyticsEvent { category: string; action: string; label?: string; value?: number; } export interface IAnalyticsFacade\u0026lt;T extends IAnalyticsEvent\u0026gt; { sendEvent(event: T): void; }    Since we\u0026rsquo;re currently only tracking one \u0026ldquo;action\u0026rdquo; — clicking a box — our event type is pretty simple:\n0 1 2 3 4 5 6 7 8  /* src/events.ts */ import { IAnalyticsEvent } from \u0026#34;./analytics-facade/i-analytics-facade\u0026#34;; import Color from \u0026#34;./color\u0026#34;; export type BoxClickEvent = IAnalyticsEvent \u0026amp; { category: \u0026#39;box\u0026#39;, action: \u0026#39;click\u0026#39;, label: Color, };    On line 4 we\u0026rsquo;re taking the IAnalyticsEvent and narrowing it to specific types for category, action, and label. Now let\u0026rsquo;s write a helper function to create new events from colors:\n8 9 10 11 12 13 14  /* src/events.ts */ // ... export const boxClick = (color: Color): BoxClickEvent =\u0026gt; ({ category: \u0026#39;box\u0026#39;, action: \u0026#39;click\u0026#39;, label: color, });    Writing a simple class which can handle only our events ensures that only events which comply with our event schema are sent to GA:\n0 1 2 3 4 5 6 7 8 9  /* src/analytics-facade/analytics-facade.ts */ import { IAnalyticsFacade } from \u0026#34;./i-analytics-facade\u0026#34;; import { BoxClickEvent } from \u0026#34;../events\u0026#34;; export class AnalyticsFacade implements IAnalyticsFacade\u0026lt;BoxClickEvent\u0026gt; { public sendEvent(event: BoxClickEvent): void { // In reality, this would be a call to GA  console.debug(event); } }    Adding another event Clicks are great, but normally there are multiple events which need to be tracked. Let\u0026rsquo;s add another event for when a box is displayed (an impression):\n14 15 16 17 18 19 20 21 22 23 24 25 26  /* src/events.ts */ // ... export type BoxImpressionEvent = IAnalyticsEvent \u0026amp; { category: \u0026#39;box\u0026#39;, action: \u0026#39;impression\u0026#39;, label: Color, }; export const boxImpression = (color: Color): BoxImpressionEvent =\u0026gt; ({ category: \u0026#39;box\u0026#39;, action: \u0026#39;impression\u0026#39;, label: color, });    We can wrap up all of our event types into a union type to use with our AnalyticsFacade:\n26 27 28  /* src/events.ts */ // ... export type AppEvent = BoxClickEvent | BoxImpressionEvent;    2 3 4 5 6 7 8  /* src/analytics-facade/analytics-facade.ts */ // ... export class AnalyticsFacade implements IAnalyticsFacade\u0026lt;AppEvent\u0026gt; { public sendEvent(event: AppEvent): void { console.debug(event); } }    Going beyond As your events grow, it\u0026rsquo;s useful to split the event type definitions and event creators into their own modules. Even further down the line, defining common properties as an enum of strings, or consolidating common collections into their own intermediate types, can make the code more clear. A contrived example with these two events could look something like this:\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  /* src/events/types.ts */ import { IAnalyticsEvent } from \u0026#34;../analytics-facade/i-analytics-facade\u0026#34;; import Color from \u0026#34;../color\u0026#34;; // Categories export enum EventCategory { Box = \u0026#39;box\u0026#39;, } // Actions export enum BoxAction { Click = \u0026#39;click\u0026#39;, Impression = \u0026#39;impression\u0026#39;, } type EventAction = BoxAction; // Labels type BoxLabel = Color; type EventLabel = BoxLabel; // Events /** * The base event which can only be of a predefined `category`, `action`, and `label` * the `label` narrowing may not fit all use cases */ export type AppEvent = IAnalyticsEvent \u0026amp; { category: EventCategory, action: EventAction, label: EventLabel, } /** * Events for the `Box` category */ type BoxEvent = AppEvent \u0026amp; { category: EventCategory.Box, action: BoxAction, label: BoxLabel, }; export type BoxClickEvent = BoxEvent \u0026amp; { action: BoxAction.Click }; export type BoxImpressionEvent = BoxEvent \u0026amp; { action: BoxAction.Impression, };    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* src/events/creators.ts */ import { BoxClickEvent, BoxImpressionEvent, EventCategory, BoxAction } from \u0026#34;./types\u0026#34;; import Color from \u0026#34;../color\u0026#34;; export const boxClick = (color: Color): BoxClickEvent =\u0026gt; ({ category: EventCategory.Box, action: BoxAction.Click, label: color, }); export const boxImpression = (color: Color): BoxImpressionEvent =\u0026gt; ({ category: EventCategory.Box, action: BoxAction.Impression, label: color, });    Conclusion Ensuring that GA data is structured and conforming to a specific schema can be business critical, and can save having to painstakingly fix or throw out valuable data. Leveraging Typescript to ensure that code cannot send incorrect data is another line of defense which I can recommend.\nFeedback, questions, and comments are always welcome! You can find me on Twitter. Happy coding!\n","permalink":"rakenodiax.github.io/posts/strongly-typed-google-analytics-events/","summary":"For MealSpotter, we use Google Analytics Events to help us better understand how well Deals are performing, and bring that insight to our restaurant partners. Ensuring that our analytics data are clean helps us to work with our partners to bring even better deals to our users.\nThis post will go into how to define an Events schema using Typescript, using a simplified example of the method we use at MealSpotter.\nEach event contains the following data:","title":"Strongly Typed Google Analytics Events with Typescript"},{"content":"Rust support on AWS Lambda was recently released, which seems like as good an opportunity as any to share some code and the solutions to challenges I encountered along the way ☺. I\u0026rsquo;ve decided to create a little diceware service, and the lambda-runtime crate provides a great API to make this a breeze.\nSetting up the library We\u0026rsquo;re going to generate a basic crate:\n$ cargo new dicers --lib \u0026amp;\u0026amp; cd dicers Created library `dicers` project You should see a structure similar to this:\n$ ls -a ./\t.git/\tCargo.toml ../\t.gitignore\tsrc/ Write the core data structure I\u0026rsquo;m going to expose the phrase generator as a dictionary which implements an Iterator, from which the user can take however many words needed for the phrase. Iterators also provide a nice way to seed and add to the dictionary. The Rust standard library includes traits for both of these features: FromIterator and Extend; we\u0026rsquo;ll write two quick tests to describe this behavior:\n#[cfg(test)] mod tests { use super::*; #[test] fn dictionary_implements_from_iterator() { let seed = || vec![\u0026#34;foo\u0026#34;.to_string(), \u0026#34;bar\u0026#34;.to_string()].into_iter(); let dictionary = Dictionary::from_iter(seed()); assert_eq!(dictionary.words, HashSet::from_iter(seed())); } #[test] fn dictionary_implements_extend() { let addition = || vec![\u0026#34;foo\u0026#34;.to_string(), \u0026#34;bar\u0026#34;.to_string()].into_iter(); let mut dictionary = Dictionary::default(); dictionary.extend(addition()); assert_eq!( dictionary.words, HashSet::from_iter(addition().map(|s| s.to_string())) ); } }  cargo test prompts us to create a Dictionary struct and import HashSet. We can derive some basic traits for Dictionary while we\u0026rsquo;re at it:\nuse std::collections::HashSet; #[derive(Debug, Default, Clone, PartialEq)] pub struct Dictionary { words: HashSet\u0026lt;String\u0026gt; }  Now cargo test leads us to import the appropriate traits so they can be used:\nuse std::collections::HashSet; use std::iter::{Extend, FromIterator};  Implementing Extend and FromIterator is incredibly easy, as the underlying HashSet implements them:\nimpl\u0026lt;S\u0026gt; FromIterator\u0026lt;S\u0026gt; for Dictionary where S: ToString, { fn from_iter\u0026lt;I: IntoIterator\u0026lt;Item = S\u0026gt;\u0026gt;(iter: I) -\u0026gt; Dictionary { let words = HashSet::from_iter(iter.into_iter().map(|s| s.to_string())); Dictionary { words } } } impl\u0026lt;S\u0026gt; Extend\u0026lt;S\u0026gt; for Dictionary where S: ToString, { fn extend\u0026lt;I: IntoIterator\u0026lt;Item = S\u0026gt;\u0026gt;(\u0026amp;mut self, iter: I) { self.words.extend(iter.into_iter().map(|s| s.to_string())); } }  And now the tests pass, yay!\nrunning 2 tests test tests::dictionary_implements_from_iterator ... ok test tests::dictionary_implements_extend ... ok test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out Iterating over generated words Now we\u0026rsquo;ll implement Iterator for Dictionary. This iterator will return a random word each time next is called. First things first, we\u0026rsquo;ll write a test that exercises this behavior:\n#[test] fn dictionary_can_be_iterated_over() { let word = \u0026#34;foo\u0026#34;; let dictionary = Dictionary::from_iter(vec![word].into_iter()); let generated = dictionary.iter().next(); assert_eq!(generated, Some(word)); }  Each time the dictionary is iterated over, a separate RNG will be instantiated. A DictionaryIterator struct contains a borrow of the Dictionary.words, and the RNG:\nuse rand::prelude::*;  impl Dictionary { pub fn iter(\u0026amp;self) -\u0026gt; DictionaryIterator { DictionaryIterator::new(\u0026amp;self.words) } } pub struct DictionaryIterator\u0026lt;\u0026#39;a\u0026gt; { words: \u0026amp;\u0026#39;a HashSet\u0026lt;String\u0026gt;, rng: ThreadRng, } impl\u0026lt;\u0026#39;a\u0026gt; DictionaryIterator\u0026lt;\u0026#39;a\u0026gt; { fn new(words: \u0026amp;\u0026#39;a HashSet\u0026lt;String\u0026gt;) -\u0026gt; DictionaryIterator\u0026lt;\u0026#39;a\u0026gt; { let rng = thread_rng(); DictionaryIterator { words, rng } } } impl\u0026lt;\u0026#39;a\u0026gt; Iterator for DictionaryIterator\u0026lt;\u0026#39;a\u0026gt; { type Item = \u0026amp;\u0026#39;a str; fn next(\u0026amp;mut self) -\u0026gt; Option\u0026lt;Self::Item\u0026gt; { let word_count = self.words.len(); let index = self.rng.gen_range(0, word_count); self.words.iter().nth(index).map(|s| s.as_str()) } } \nDon\u0026rsquo;t forget to add rand as a dependency to Cargo.toml:\n[dependencies] rand = \u0026#34;0.6.1\u0026#34; Using an iterator allows the use of take to generate arbitrary numbers of words:\nlet four = dictionary.iter().take(4);  Populating the dictionary In actual use, the Dictionary needs to be seeded with a given set of words. We\u0026rsquo;ll store this in a text file, with each line being a word in the dictionary, and add support to read any string in this format and create a Dictionary from it:\nimpl Dictionary { pub fn read_str(input: \u0026amp;str) -\u0026gt; Dictionary { // `String.lines` implements `Iterator`, so we can use it directly with `FromIterator`  Dictionary::from_iter(input.lines()) } }  Building against AWS Lambda The lambda-runtime crate is pretty simple to use. We define a handler function which takes a serde deserializable struct and context, returning either a serde serializable struct or an error. Let\u0026rsquo;s start by adding the necessary dependencies to Cargo.toml:\nlambda_runtime = \u0026#34;0.1.0\u0026#34; serde_derive = \u0026#34;1.0.80\u0026#34; We\u0026rsquo;ll implement the API in a separate module: create src/api.rs and declare the module in src/lib.rs:\nmod api; pub use self::api::handler;  We\u0026rsquo;ll start with the request and response structs, in src/api.rs:\nuse serde_derive::{Deserialize, Serialize}; #[derive(Debug, Deserialize)] pub struct GenerateEvent { word_count: u8, separator: char, } #[derive(Debug, Serialize)] pub struct GenerateResponse { phrase: String, }  The business logic is simple enough that we can just implement it directly in the handler function used by Lambda.\nuse super::Dictionary;  pub fn handler(event: GenerateEvent, _ctx: Context) -\u0026gt; Result\u0026lt;GenerateResponse, HandlerError\u0026gt; { match event { GenerateEvent { word_count, separator: Some(separator), } =\u0026gt; { let seed = include_str!(\u0026#34;../resources/dictionary.txt\u0026#34;); let dictionary = Dictionary::read_str(\u0026amp;seed); let words: Vec\u0026lt;\u0026amp;str\u0026gt; = dictionary.iter().take(word_count as usize).collect(); let phrase = words.as_slice().join(\u0026amp;separator.to_string()); Ok(GenerateResponse { phrase }) } GenerateEvent { word_count, separator: None, } =\u0026gt; { let seed = include_str!(\u0026#34;../resources/dictionary.txt\u0026#34;); let dictionary = Dictionary::read_str(\u0026amp;seed); // Iterators of type `\u0026amp;str` can be joined into one `String` with `collect`  let phrase: String = dictionary.iter().take(word_count as usize).collect(); Ok(GenerateResponse { phrase }) } } } \nThis implementation can definitely be cleaned up; there\u0026rsquo;s the repeated logic of reading the dictionary file, along with unwrap, which means that the function could panic at runtime. We can clean this up by using the lazy_static crate:\nuse lazy_static::lazy_static; use serde_derive::{Deserialize, Serialize}; lazy_static! { static ref DICTIONARY: Dictionary = { let seed = include_str!(\u0026#34;../resources/dictionary.txt\u0026#34;); Dictionary::read_str(\u0026amp;seed) } }  The dictionary will now be instantiated the first time it\u0026rsquo;s used. Let\u0026rsquo;s use the dictionary in our handler:\npub fn handler(event: GenerateEvent, _ctx: Context) -\u0026gt; Result\u0026lt;GenerateResponse, HandlerError\u0026gt; { match event { GenerateEvent { word_count, separator: Some(separator), } =\u0026gt; { let words: Vec\u0026lt;\u0026amp;str\u0026gt; = DICTIONARY.iter().take(word_count as usize).collect(); let phrase = words.as_slice().join(\u0026amp;separator.to_string()); Ok(GenerateResponse { phrase }) } GenerateEvent { word_count, separator: None, } =\u0026gt; { // Iterators of type `\u0026amp;str` can be joined into one `String` with `collect`  let phrase: String = DICTIONARY.iter().take(word_count as usize).collect(); Ok(GenerateResponse { phrase }) } } }  Write a main function The lambda_runtime crate provides a macro for exposing a handler function to Lambda. The complete main.rs file:\nuse dicers::handler; use lambda_runtime::lambda; fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn std::error::Error\u0026gt;\u0026gt; { lambda!(handler); Ok(()) }  Deploy to AWS Lambda The crate must be built for the x86_64-unknown-linux-musl target. If you are MacOS, the following steps will allow for cross compilation:\n# Add the target via rustup $ rustup target add x86_64-unknown-linux-musl # install the homebrew cross-compilation binaries $ brew install filosottile/musl-cross/musl-cross # cargo can\u0026#39;t find the default binary name, so we use a symlink to the one it is expecting $ ln -s /usr/local/bin/x86_64-linux-musl-gcc /usr/local/bin/musl-gcc And add the following configuration file, located at .cargo/config:\n[build] target = \u0026#34;x86_64-unknown-linux-musl\u0026#34; [target.x86_64-unknown-linux-musl] linker = \u0026#34;x86_64-linux-musl-gcc\u0026#34; This will tell cargo to build for the appropriate target, and use the linker we just installed. Now we can build and publish the Lambda function using the AWS CLI:\n# Build with optimizations $ cargo build --release # Copy the binary as a bootstrap file $ cp ./target/x86_64-unknown-linux-musl/release/dicers ./bootstrap # Compress into a lambda archive and remove the intermediary bootstrap file $ zip lambda.zip bootstrap \u0026amp;\u0026amp; rm bootstrap # Replace the `role` argument with the Role ARN from the AWS IAM console. The user must be granted the `lambda:CreateFunction` permission and the role allowed `XRay:PutTraceSegments`: $ aws lambda create-function --function-name dicers \\ --handler doesnt.matter \\ --zip-file fileb://./lambda.zip \\ --runtime provided \\ --role arn:aws:iam::XXXXXXXXXXX:role/my-role \\ --environment Variables={RUST_BACKTRACE=1} \\ --tracing-config Mode=Active And now we can use a test invocation to ensure it\u0026rsquo;s up and running:\n$ aws lambda invoke --function-name dicers \\ --payload \u0026#39;{\u0026#34;word_count\u0026#34;: 5, \u0026#34;separator\u0026#34;:\u0026#34;-\u0026#34;}\u0026#39; \\ output.json { \u0026#34;StatusCode\u0026#34;: 200, \u0026#34;ExecutedVersion\u0026#34;: \u0026#34;$LATEST\u0026#34; } $ cat output.json {\u0026#34;phrase\u0026#34;:\u0026#34;heading-reimburse-preformed-pledge-appliance\u0026#34;} And that should be it! The final source can be found here.\nI\u0026rsquo;d love to get feedback on this post: discuss on Reddit, open a GitLab Issue or send me a tweet.\n","permalink":"rakenodiax.github.io/posts/dicers-rust-on-lambda/","summary":"Rust support on AWS Lambda was recently released, which seems like as good an opportunity as any to share some code and the solutions to challenges I encountered along the way ☺. I\u0026rsquo;ve decided to create a little diceware service, and the lambda-runtime crate provides a great API to make this a breeze.\nSetting up the library We\u0026rsquo;re going to generate a basic crate:\n$ cargo new dicers --lib \u0026amp;\u0026amp; cd dicers Created library `dicers` project You should see a structure similar to this:","title":"Dice.rs: Rust on Lambda"}]